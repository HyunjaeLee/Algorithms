---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: mo/hilbert_mo.hpp
    title: mo/hilbert_mo.hpp
  - icon: ':heavy_check_mark:'
    path: mo/mo_tree.hpp
    title: mo/mo_tree.hpp
  - icon: ':heavy_check_mark:'
    path: mo/sqrt_freq_table.hpp
    title: mo/sqrt_freq_table.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/problems/0489
    links:
    - https://onlinejudge.u-aizu.ac.jp/problems/0489
  bundledCode: "#line 1 \"test/mo/aoj0489.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/0489\"\
    \n\n#line 1 \"mo/mo_tree.hpp\"\n\n\n\n#line 1 \"mo/hilbert_mo.hpp\"\n\n\n\n#include\
    \ <algorithm>\n#include <array>\n#include <cassert>\n#include <vector>\n\nstruct\
    \ HilbertMo {\n    HilbertMo(int n) : n_(n), log_(std::bit_width(unsigned(n)))\
    \ {}\n    void add(int l, int r) {\n        assert(0 <= l && l <= r && r <= n_);\n\
    \        auto index = int(queries_.size());\n        auto order = hilbert_order(l,\
    \ r);\n        queries_.push_back({l, r, index, order});\n    }\n    void solve(auto\
    \ add, auto remove, auto eval) { solve(add, add, remove, remove, eval); }\n  \
    \  void solve(auto add_left, auto add_right, auto remove_left, auto remove_right,\
    \ auto eval) {\n        sort(queries_.begin(), queries_.end());\n        auto\
    \ l = 0, r = 0;\n        for (auto [left, right, index, order] : queries_) {\n\
    \            while (left < l) {\n                add_left(--l);\n            }\n\
    \            while (r < right) {\n                add_right(r++);\n          \
    \  }\n            while (l < left) {\n                remove_left(l++);\n    \
    \        }\n            while (right < r) {\n                remove_right(--r);\n\
    \            }\n            eval(index);\n        }\n    }\n\nprivate:\n    struct\
    \ query {\n        int left, right, index;\n        long long order;\n       \
    \ bool operator<(const query &other) const { return order < other.order; }\n \
    \   };\n    long long hilbert_order(int x, int y) const {\n        auto d = 0LL;\n\
    \        for (auto s = 1 << log_; s > 0; s >>= 1) {\n            bool rx = x &\
    \ s, ry = y & s;\n            d = (d << 2) | ((rx * 3) ^ ry);\n            if\
    \ (!ry) {\n                if (rx) {\n                    x = ~x;\n          \
    \          y = ~y;\n                }\n                std::swap(x, y);\n    \
    \        }\n        }\n        return d;\n    }\n    std::vector<query> queries_;\n\
    \    const int n_, log_;\n};\n\n\n#line 7 \"mo/mo_tree.hpp\"\n#include <utility>\n\
    #line 9 \"mo/mo_tree.hpp\"\n\nstruct MoTree {\n    explicit MoTree(const std::vector<std::vector<int>>\
    \ &adj)\n        : n_(int(adj.size())), in_(n_), tour_(2 * n_), top_(n_), parent_(n_),\
    \ mo_(2 * n_) {\n        auto timer = 0;\n        std::vector<int> size(n_, 1),\
    \ heavy(n_, -1);\n        auto dfs = [&](auto &&self, int u) -> void {\n     \
    \       for (auto v : adj[u]) {\n                if (v != parent_[u]) {\n    \
    \                parent_[v] = u;\n                    self(self, v);\n       \
    \             size[u] += size[v];\n                    if (heavy[u] == -1 || size[heavy[u]]\
    \ < size[v]) {\n                        heavy[u] = v;\n                    }\n\
    \                }\n            }\n        };\n        auto hld = [&](auto &&self,\
    \ int u) -> void {\n            in_[u] = timer;\n            tour_[timer++] =\
    \ u;\n            for (auto v : adj[u]) {\n                if (v != parent_[u])\
    \ {\n                    top_[v] = (v == heavy[u]) ? top_[u] : v;\n          \
    \          self(self, v);\n                }\n            }\n            tour_[timer++]\
    \ = u;\n        };\n        dfs(dfs, 0);\n        hld(hld, 0);\n    }\n    int\
    \ lca(int u, int v) const {\n        assert(0 <= u && u < n_ && 0 <= v && v <=\
    \ n_);\n        while (top_[u] != top_[v]) {\n            if (in_[top_[u]] < in_[top_[v]])\
    \ {\n                std::swap(u, v);\n            }\n            u = parent_[top_[u]];\n\
    \        }\n        return (in_[u] < in_[v]) ? u : v;\n    }\n    void add(int\
    \ u, int v) {\n        assert(0 <= u && u < n_ && 0 <= v && v <= n_);\n      \
    \  lca_.push_back(lca(u, v));\n        auto [l, r] = std::minmax(in_[u], in_[v]);\n\
    \        mo_.add(l + 1, r + 1);\n    }\n    void solve(auto add, auto remove,\
    \ auto eval) {\n        std::vector<bool> contains(n_);\n        auto toggle =\
    \ [&](int i) {\n            auto u = tour_[i];\n            if (contains[u]) {\n\
    \                remove(u);\n            } else {\n                add(u);\n \
    \           }\n            contains[u].flip();\n        };\n        auto eval_lca\
    \ = [&](int i) {\n            toggle(in_[lca_[i]]);\n            eval(i);\n  \
    \          toggle(in_[lca_[i]]);\n        };\n        mo_.solve(toggle, toggle,\
    \ eval_lca);\n    }\n\nprivate:\n    int n_;\n    std::vector<int> in_, tour_,\
    \ top_, parent_, lca_;\n    HilbertMo mo_;\n};\n\n\n#line 1 \"mo/sqrt_freq_table.hpp\"\
    \n\n\n\n#line 6 \"mo/sqrt_freq_table.hpp\"\n#include <cmath>\n#line 8 \"mo/sqrt_freq_table.hpp\"\
    \n\nstruct SqrtFreqTable {\n    explicit SqrtFreqTable(int max_val)\n        :\
    \ m_(std::max(1, max_val)), b_sz_(int(std::sqrt(m_))), freq_(m_ + 1),\n      \
    \    bucket_(m_ / b_sz_ + 1) {}\n    void insert(int x) { // O(1)\n        assert(0\
    \ <= x && x <= m_);\n        ++freq_[x];\n        ++bucket_[x / b_sz_];\n    \
    \    ++total_;\n        distinct_ += int(freq_[x] == 1);\n    }\n    void erase(int\
    \ x) { // O(1)\n        assert(0 <= x && x <= m_);\n        assert(0 < freq_[x]);\n\
    \        --freq_[x];\n        --bucket_[x / b_sz_];\n        --total_;\n     \
    \   distinct_ -= int(freq_[x] == 0);\n    }\n    int count(int x) const { // O(1)\n\
    \        assert(0 <= x && x <= m_);\n        return freq_[x];\n    }\n    int\
    \ size() const { return total_; }\n    int count_distinct() const { return distinct_;\
    \ }\n    int kth(int k) const { // O(sqrt(M)), 0-indexed\n        auto cnt = 0;\n\
    \        for (auto i = 0; i < m_ / b_sz_ + 1; ++i) {\n            if (cnt + bucket_[i]\
    \ <= k) {\n                cnt += bucket_[i];\n                continue;\n   \
    \         }\n            auto x = i * b_sz_;\n            while ((cnt += freq_[x])\
    \ <= k) {\n                ++x;\n            }\n            return x;\n      \
    \  }\n        return -1;\n    };\n    int rank(int x) const { // O(sqrt(M)), count\
    \ y s.t. y < x\n        assert(0 <= x);\n        if (m_ < x) {\n            return\
    \ total_;\n        }\n        auto cnt = 0;\n        for (auto i = 0; i < x /\
    \ b_sz_; ++i) {\n            cnt += bucket_[i];\n        }\n        for (auto\
    \ i = x / b_sz_ * b_sz_; i < x; ++i) {\n            cnt += freq_[i];\n       \
    \ }\n        return cnt;\n    }\n\nprivate:\n    const int m_, b_sz_;\n    std::vector<int>\
    \ freq_, bucket_;\n    int total_ = 0, distinct_ = 0;\n};\n\n\n#line 5 \"test/mo/aoj0489.test.cpp\"\
    \n#include <bits/stdc++.h>\n\nint main() {\n    std::cin.tie(0)->sync_with_stdio(0);\n\
    \    int N, M;\n    std::cin >> N >> M;\n    std::vector<int> A(N);\n    for (auto\
    \ &x : A) {\n        std::cin >> x;\n    }\n    std::vector<std::vector<int>>\
    \ adj(N);\n    for (auto i = 0; i < N - 1; ++i) {\n        int u, v;\n       \
    \ std::cin >> u >> v;\n        --u, --v;\n        adj[u].push_back(v);\n     \
    \   adj[v].push_back(u);\n    }\n    std::vector<std::tuple<int, int, int>> queries;\n\
    \    for (auto i = 0; i < M; ++i) {\n        int op;\n        std::cin >> op;\n\
    \        if (op == 1) {\n            int u, w;\n            std::cin >> u >> w;\n\
    \            --u;\n            auto v = int(adj.size());\n            A.push_back(w);\n\
    \            adj.emplace_back();\n            adj[u].push_back(v);\n         \
    \   adj[v].push_back(u);\n        } else {\n            int u, v, k;\n       \
    \     std::cin >> u >> v >> k;\n            --u, --v, --k;\n            queries.emplace_back(u,\
    \ v, k);\n        }\n    }\n    auto C = A;\n    std::ranges::sort(C);\n    C.erase(unique(C.begin(),\
    \ C.end()), C.end());\n    for (auto &x : A) {\n        auto it = std::ranges::lower_bound(C,\
    \ x);\n        x = int(it - C.begin());\n    }\n    MoTree mo(adj);\n    for (auto\
    \ [u, v, k] : queries) {\n        mo.add(u, v);\n    }\n    SqrtFreqTable table(int(C.size())\
    \ - 1);\n    std::vector<int> ans(queries.size());\n    auto add = [&](int u)\
    \ { table.insert(A[u]); };\n    auto remove = [&](int u) { table.erase(A[u]);\
    \ };\n    auto eval = [&](int i) {\n        auto [u, v, k] = queries[i];\n   \
    \     ans[i] = C[table.kth(k)];\n    };\n    mo.solve(add, remove, eval);\n  \
    \  std::ranges::copy(ans, std::ostream_iterator<int>(std::cout, \"\\n\"));\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/0489\"\n\n#include\
    \ \"mo/mo_tree.hpp\"\n#include \"mo/sqrt_freq_table.hpp\"\n#include <bits/stdc++.h>\n\
    \nint main() {\n    std::cin.tie(0)->sync_with_stdio(0);\n    int N, M;\n    std::cin\
    \ >> N >> M;\n    std::vector<int> A(N);\n    for (auto &x : A) {\n        std::cin\
    \ >> x;\n    }\n    std::vector<std::vector<int>> adj(N);\n    for (auto i = 0;\
    \ i < N - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u,\
    \ --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n  \
    \  std::vector<std::tuple<int, int, int>> queries;\n    for (auto i = 0; i < M;\
    \ ++i) {\n        int op;\n        std::cin >> op;\n        if (op == 1) {\n \
    \           int u, w;\n            std::cin >> u >> w;\n            --u;\n   \
    \         auto v = int(adj.size());\n            A.push_back(w);\n           \
    \ adj.emplace_back();\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n\
    \        } else {\n            int u, v, k;\n            std::cin >> u >> v >>\
    \ k;\n            --u, --v, --k;\n            queries.emplace_back(u, v, k);\n\
    \        }\n    }\n    auto C = A;\n    std::ranges::sort(C);\n    C.erase(unique(C.begin(),\
    \ C.end()), C.end());\n    for (auto &x : A) {\n        auto it = std::ranges::lower_bound(C,\
    \ x);\n        x = int(it - C.begin());\n    }\n    MoTree mo(adj);\n    for (auto\
    \ [u, v, k] : queries) {\n        mo.add(u, v);\n    }\n    SqrtFreqTable table(int(C.size())\
    \ - 1);\n    std::vector<int> ans(queries.size());\n    auto add = [&](int u)\
    \ { table.insert(A[u]); };\n    auto remove = [&](int u) { table.erase(A[u]);\
    \ };\n    auto eval = [&](int i) {\n        auto [u, v, k] = queries[i];\n   \
    \     ans[i] = C[table.kth(k)];\n    };\n    mo.solve(add, remove, eval);\n  \
    \  std::ranges::copy(ans, std::ostream_iterator<int>(std::cout, \"\\n\"));\n}\n"
  dependsOn:
  - mo/mo_tree.hpp
  - mo/hilbert_mo.hpp
  - mo/sqrt_freq_table.hpp
  isVerificationFile: true
  path: test/mo/aoj0489.test.cpp
  requiredBy: []
  timestamp: '2026-02-27 15:20:30+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/mo/aoj0489.test.cpp
layout: document
redirect_from:
- /verify/test/mo/aoj0489.test.cpp
- /verify/test/mo/aoj0489.test.cpp.html
title: test/mo/aoj0489.test.cpp
---
